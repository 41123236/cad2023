var tipuesearch = {"pages": [{'title': 'About', 'text': ' https://github.com/mdecycu/cmsite \n', 'tags': '', 'url': 'About.html'}, {'title': '作業區', 'text': '', 'tags': '', 'url': '作業區.html'}, {'title': '組合圖', 'text': '\n 零件圖   \n', 'tags': '', 'url': '組合圖.html'}, {'title': 'Brython', 'text': '\n https://en.wikipedia.org/wiki/Python_(programming_language) \n Examples: \n https://gist.github.com/mdecycu/d9082d678096bd58378d6afe2c7fa05d \n https://www.geeksforgeeks.org/python-programming-examples/ \n https://www.programiz.com/python-programming/examples \n https://www.freecodecamp.org/news/python-code-examples-sample-script-coding-tutorial-for-beginners/ \n Python Tutorial: \n https://docs.python.org/3/tutorial/ \n An informal introduction to Python \n Indentation (Python 採 4 個 Spaces 縮排, 以界定執行範圍) \n Variables ( Python Keywords ) \n Comments (# 單行註解, 三個單引號或三個雙引號標註多行註解) \n Numbers  (整數 int(), 浮點數 float()) \n Strings  (字串) \n print (Python 內建函式,  print()  函式) \n Python control flow tools \n for \n if \n range \n open \n read \n lists \n tuples \n dictionaries \n functions \n try ... except \n break \n pass \n classes \n 這個頁面 demo 如何在同一頁面下納入多個線上 Ace 編輯器與執行按鈕 ( practice_html.txt  動態頁面超文件). \n practice_html.txt  動態頁面超文件應該可以在啟動 Brython 時, 設定將 .py 檔案放入 downloads/py 目錄中引用. \n 亦即將所有對應的 html 也使用 Brython 產生, 然後寫為  class  後, 在範例導入時透過  instance  引用. \n <!-- 啟動 Brython -->\n<script>\nwindow.onload=function(){\nbrython({debug:1, pythonpath:[\'./../cmsimde/static/\',\'./../downloads/py/\']});\n}\n</script> \n 從 1 累加到 100: \n 1 add to 100 \n 將 iterable 與 iterator  相關說明 , 利用 Brython 與 Ace Editor 整理在這個頁面. \n \n  導入 brython 程式庫  \n \n \n \n \n  啟動 Brython  \n \n \n \n  導入 FileSaver 與 filereader  \n \n \n \n \n  導入 ace  \n \n \n \n \n \n \n  導入 gearUtils-0.9.js Cango 齒輪繪圖程式庫  \n \n \n \n \n \n \n  請注意, 這裡使用 Javascript 將 localStorage["kw_py_src1"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n \n \n \n  add 1 to 100 開始  \n \n \n  add 1 to 100 結束 \n  editor1 開始  \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  \n Filename:  .py   \n  存擋表單結束  \n \n  執行與清除按鈕開始  \n Run   Output   清除輸出區 清除繪圖區 Reload \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n  Brython 程式執行的結果, 都以 brython_div1 作為切入位置  \n \n  editor1 結束   ##########################################  \n 從 1 累加到 100 part2: \n 1 add to 100 cango_three_gears BSnake AI Tetris Rotating Block \n  請注意, 這裡使用 Javascript 將 localStorage["kw_py_src2"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n  add 1 to 100 part2 開始  \n \n \n  add 1 to 100 part2 結束 \n  editor2 開始  \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  \n Filename:  .py   \n  存擋表單結束  \n \n  執行與清除按鈕開始  \n Run   Output   清除輸出區 清除繪圖區 Reload \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n  Brython 程式執行的結果, 都以 brython_div1 作為切入位置  \n \n  editor2 結束  \n \n \n \n', 'tags': '', 'url': 'Brython.html'}, {'title': 'HW', 'text': '', 'tags': '', 'url': 'HW.html'}, {'title': 'W9-W11', 'text': '\n 下載整合網路設定、可攜程式系統以及執行可攜 Solid Edge 的 reg 與 batch files.7z \xa0 (需要密碼) \n 請各分組實際操作 \xa0 https://mde.tw/pjcopsim/content/bubbleRobTutorial.html \xa0 之後, 將操作過程與心得放入各組的分組網站中 (頁面標題為 w11), 並說明各組員在過程中所負責的工作內容與任務, 各組員所負責的項目請放入個人的網頁中. \n 過程中所遭遇問題, 請各組員利用 Teams 詢問 (CAD2023 MS Teams 代碼為: fnueb56). \n 執行 perpetual motion simulator 系統: \n 紀錄鋼球運動速度: \xa0 1 , \xa0 2 . \n 對模擬物件施力: \xa0 1 \xa0 (non-central), \xa0 2 \xa0 (center of mass), \xa0 3 \xa0 (施力並設定材料性質). \n 模擬電磁力: \xa0 1 , \xa0 2 . \n CoppeliaSim 鋼球永動模擬器電腦輔助設計三個階段: 建立模型零組件 - 轉入機電模擬系統 - 根據實際物理條件設置機電系統.\xa0 perpetual_motion_simulator_project_cad2023.7z 下載 \xa0 (需要密碼) \n 雲端、區網與近端環境中的電腦輔助設計環境: \n 直接在網路上進行電腦輔助設計的好處雖然很多, 但是在 商用的雲端系統 , 例如: Github 或 Replit, 使用者只能依照服務提供者的方法及流程進行應用, 當 Github 宣布在 2023 年底之前各用戶必須使用 2FA 認證登入, 使用者只能照辦, 否則帳號就可能被禁用. \n 作為 Replit 的免付費用戶也處於相同的情況, 當服務提供者宣布在 2024 年初開始, 只有付費用戶可以使用廣域的 Webview, 若希望仍維持免付費使用 (目前 \xa0 Replit Core 年費 \xa0 120 美元), 屆時再看是否能繼續開啟動態網站編輯, 並將改版內容提交推送到 Github 倉儲, 以便採分散式版次管理流程維護 Github Pages 網站. \n 同樣利用網路服務, 但設法將所有超過兩百名用戶集中到 自行搭建的廣域網站 系統, 也可以擁有類似 Replit 上維護網站內容的優點, 可是壞處是在系上工作站室所設定的軟硬體與網路連線, 都必須自行維護, 可用性與穩定度都遠遠不及商用的雲端系統. \n 另外, 在無網路連線的情況下, 若先前已經將 Github 上倉儲, git clone 到 近端硬碟或隨身碟 , 使用者仍可以直接利用可攜程式系統, 執行動態網站並針對電腦輔助流程新增提交改版內容, 等到有網路連線的時段再將資料推送到 Github. \n 最後, 假如系上的連外網路無法順利與 Github 相連, 所有電腦輔助設計與協同都必須在區網進行, 則可以使用 \xa0 Fossil SCM \xa0 進行各學員的分散式版次管理. (請參考 這裡 的說明). \n 循著上述相同的網路或自主環境, 利用 \xa0 Onshape \xa0 就與商用雲端系統相似, 一定要上網才能進行輔助設計繪圖, 而在系上或學校網路認證才能開啟的 \xa0 NX 或 SolidWorks , 就必須在自行搭建的認證主機能夠運作, 才可連線認證後開啟. 至於 \xa0 Solid Edge 可攜版與 Solvespace \xa0 則可以在沒有網路連線的情況下進行零組件的設計繪圖. \n \n w10 網路狀態: 目前似乎從學校電腦無法使用 hinet 的 IPv6 DNS 伺服器. 驗證方式: 在命令列中輸入 nslookup, 然後以 server 2001:b000:168::1 指令將 DNS 設為中華電信的符號名稱伺服器, 然後查詢 google.com. \n 因應方法: 使用機械設計系所建立的 DNS 伺服器, 140.130.17.3 以及 \xa0 2001:288:6004:17::3 \n 無法使用中華電信 DNS 原因: 應該是學校網管修改設定, 禁止跨區設定 DNS 伺服器. \n w10 Ubuntu 問題: 22.04 版更為最新後, netplan 在無 openvswitch 啟動的情況下無法更新設定. \n 先處理 /etc/netplan/net.yaml 中 DNS 伺服器改為系上主機, 在無法使用 sudo netplan apply 更新 /etc/netplan/net.yaml 設定之前, 可以查詢 /etc/environment 中是否使用 IPv6 address 進行設定 http_proxy 與 https_proxy 變數. 或者修改 /etc/resolv.conf 中的 nameserver 設定, 讓 net.yaml 中的 DNS 設定可以運作. 且利用 \xa0 sudo apt install openvswitch-switch \xa0 安裝並執行 netplan 所需的服務 (其實是 bug, 但為了能讓 netplan 正常運作的權宜之策). \n 有關電腦輔助設計室網路設定: \n w10_2b_cadlab_network_setting.7z \xa0 (需要下載密碼) - 電腦輔助設計室網路設定批次與 Powershell 檔案. \n tinyc.7z \xa0 (需要下載密碼) - 使用 Tiny C Compiler 編譯 C 程式, 包含 gd 與 gnuplot. \n python3114_git_putty.7z \xa0 (需要下載密碼) - 將近端 cmsimde 啟動並改版後推向 Github 所需的檔案. \n 若電腦輔助設計室網路不順, 可以先將倉儲 clone 到隨身碟, 並利用近端工具進行輔助設計且改版後 (git add and git commit), 等到網路順暢時才 push. \n \n creo 10 安裝流程的 wink 專案檔案下載 \xa0 (需要密碼) \n 有關線上簡報、網誌與多媒體影片製作工具, 請參考: \xa0 https://mde.tw/cpnote/content/w10.html \n 有關學習計算機程式與電腦輔助設計相關課程的心態與方法, 請參考 這裡 的說明. \n 因為 Python 3.12.0 環境下 Leo Editor 還無法正常透過 pip 安裝, 因此必須手動安裝 PyQt5 之後, 再使用 pip install leo, 所完成的 Python 3.12.0:\xa0 Python312_leo_664_PyQt5.7z \xa0 (需要下載密碼) \n 有關口頭報告 (oral presentation): \n PowerPoint vs reveal.js: Choosing Presentation Tools (softwarekeep.com) \xa0 \n https://ithelp.ithome.com.tw/articles/10185467 \xa0 \n cad2023 倉儲中的 reveal.js:\xa0 https://mde.tw/cadnote/reveal/ \xa0 \n 有關永動機運動模擬玩具 (perpetual motion simulator toy): \n CAD 零組件繪圖 \n 原型製作前的系統模擬與製程規劃 \n 如何學習 CoppeliaSim: \n 透過閱讀\xa0 https://mde.tw/pjcopsim \xa0中的 tutorial 與相關指令說明後, 實際操作測試並在個人網頁中記錄各項功能的使用方法. \n 進入 CoppeliaSim \xa0 Forum , 搜尋相關討論或發問. \n Arduino code to CoppeliaSim \xa0 展示. ( Horosim , \xa0 備份 ), 更早的 討論 . 虛實整合: \xa0 1 , \xa0 2 , \xa0 3 . \n 從既有討論串中學習: \xa0 1 , \n 了解與磁場模擬有關的研究: \xa0 1 \xa0 (需要下載密碼), \xa0 2 , \xa0 3 . \n 從 案例 中學習. \n 有關鋼球平衡台 (steel ball balancing platform): \n 有關虛實整合彈珠台 (cyber-physical pinball table): \n \n w8 << \xa0 Previous \xa0 Next \xa0 >> wink \n \n Copyright ©2024 All rights reserved | This template is made with \xa0 \xa0 by \xa0 Colorlib \n', 'tags': '', 'url': 'W9-W11.html'}, {'title': 'w12', 'text': '', 'tags': '', 'url': 'w12.html'}, {'title': 'W13-14', 'text': '', 'tags': '', 'url': 'W13-14.html'}, {'title': 'W15', 'text': '\n 操作考試 : 請利用自選的電腦輔助設計套件建立 \xa0 https://mde.tw/cadnote/content/pms.html \xa0 中的零組件 (尺寸與操控內容請自訂), 並加入感測器與適當的設計元件或機構, 說明預計如何令其在接上外部電源後, 能夠讓系統中的鋼球在軌道上進行永動模擬. \n 完成零組件與可行系統設計後, 請將零組件轉入 CoppeliaSim 建立模擬場景, 並在分組中自選另一名組員, 經過彼此討論後, 請利用 ZMQ remote API Python 程式互相控制對方的永動模擬場景, 以便完成兩人一組的兩則永動機模擬操作 (若找不到協同對象, 請自行用所分配到的 IPv6 位址進行控制模擬). \n 完成上述兩人一組的現場操作考試後, 請利用 Wink 製作 MP4 操作影片, 說明從零組件繪圖至完成互動控制模擬後的各階段細節, 並將上述各項內容放入個人倉儲與網站 (頁面標題請用第一階設定, 名稱為 exam). \n step1: 基本零組件設計繪圖. \n step2: 施力機構設計, 納入軌道下方控制盒中. \n step3: 將軌道、鋼球與簡化後的控制盒輸入 CoppeliaSim. \n step4: 配合控制系統設計, 納入感測器與施力機構或系統. \n step5: 在 localhost 以 IPv6 ZMQ remote API Python 程式, 配合感測器作動對鋼球施力. \n step6: 跨網路對協同組員的場景進行控制模擬. \n \n 截至 2023.12.22 Replit 仍可用來維護 Github 倉儲中的對應網站內容, 且可透過下列 html 將 Repl 嵌入網頁中: \n \n \n \n \n \n \n 1 \n \n \n \n < iframe   frameborder = "0"   width = "100%"   height = "400"   src = "https://replit.com/@wcms/cadnote?embed=true" ></ iframe > \n \n \n \n \n \n \n \n \n 例如要查詢埠號 9210 埠號的使用情形, 指令為\xa0 lsof -i :9210, 其中 ls 為 list, of 為 open file, -i 中的 i 為 internet, :9210 表示要求列出與 port 9210 有關 internet 使用相關的資料. \n 利用 s.cycu.org 維護 github.com 上的倉儲與網站內容的說明在:\xa0 https://mde.tw/cadnote/content/w8.html \xa0 \n w13-w14 << \xa0 Previous \xa0 Next \xa0 >> 網路設定 \n \n \n Copyright ©2024 All rights reserved | This template is made with \xa0 \xa0 by \xa0 Colorlib \n', 'tags': '', 'url': 'W15.html'}, {'title': '任務一', 'text': '', 'tags': '', 'url': '任務一.html'}, {'title': '磁力吸引', 'text': '有關磁力吸引的鋼球循環運動系統, 請參考 這個影片 . \xa0 或者透過課程檔案下載密碼觀看 這個影片 . \n 根據 這個網站 宣稱是此一 Perpetual Motion Simulator 的原始創作者. \n 同時參考\xa0 A perpetual motion machine powered by electromagnetism.pdf \xa0 (需要下載密碼) \n 電腦輔助設計與實習課程的任務一即可根據此一裝置的設計, 先採用電腦輔助設計軟體, 繪製系統所需的 3D 零組件, 然後轉為 STL 格式, import 進入 CoppeliaSim, 接著根據影片說明, 利用近接感測器(例如: \xa0 電感式近接開關 , \xa0 Inductive proximity sensor ) 控制電磁鐵開關, 設法透過磁力吸引讓鋼球具有足夠動能返回圓形平台. \n 有關利用 Arduino 控制卡與相關電路設計產生電磁力控制的模擬, 請參考 \xa0 PICSimLab \xa0 頁面中的說明. \n 一旦完成 CoppeliaSim 與 Arduino 電路設計等機電資系統整合模擬, 就可以進一步利用 3D printer 列印出所需零組件, 結合實體電路設計完成此一系統的虛實整合. \n 機電模擬系統: \n 下載支援 IPv6 網路協定版本 \xa0 CoppeliaSimEdu_4.5.1_rev4_for_cd2023.7z \xa0 (需要下載密碼) \n CoppeliaSim 使用者手冊 , \xa0 CoppeliaSim 4.3.0 使用手冊網站 \n 模擬磁力的 討論 , \xa0 1 , \xa0 2 \n Force Control Modeling \n simpleMagnetDemo.ttt \n 模擬原理: \n Perpetual Motion Simulator 主要的電路設計包含右側軌道下方的電磁鐵, 通電後可產生一定大小的磁吸力, 當圓形鐵球循著軌道由平台孔洞往下滾動, 經過軌道下方近接感測器 (Proximity sensor) 時 (距離 3mm-5mm), 透過感應, 控制電路將會短暫啟動電磁鐵 (10 miliseconds), 促使圓形鐵球加速滾動, 其磁力大小約略與圓形鐵球距離的平方成反比 ( Computational Electromagnetics , \xa0 磁場模擬 ). \n 因此圓形鐵球除了從平台高度落下時, 將位能轉換為動能外, 與軌道滾動磨擦以及空氣阻力所損耗的運動能, 將額外由電磁鐵開關間所得到的磁力吸引能量進行加速, 以便取得足夠的動能在脫離軌道末端後, 重新回到圓形平台. \n \n (image from \xa0 here ) \n 電磁力未啟動下的 perpetual motion simulator CoppeliaSim 場景模擬: \n \n Images and part files in Onshape \xa0 (STL file import into CoppeliaSim 尺寸由 mm 放大10 倍至 cm, 且 z 軸向上, 場景中圓球直徑為 12.825 cm, 平台圓孔直徑為 20 cm) \n \n Perpetual Motion Simulator in Onshape , 轉入 CoppeliaSim 後放大 10 倍, 且 z 軸向上之模擬場景, 下載 \xa0 perpetual motion simulator stage2.7z \xa0 (需要下載密碼) \n 有關如何在 Onshape 繪製零組件, 轉出 STL 檔案, 轉入 CoppeliaSim 並進行組件 divide and group, 請參考這個 教學影片 . \n 以下 Python 程式可在 CoppeliaSim 場景檔案中建立所需的模擬組件: \n 啟動 \xa0 CoppeliaSimEdu_4.5.1_rev4_for_cd2023.7z \xa0 (支援 IPv6 網路協定版本, 需要下載密碼), 然後在 \xa0 Portable_2023_fall_1.3g_5g.7z \xa0 (需要下載密碼) 可攜環境啟動後, 以 pip install pyzmq cbor keyboard 安裝所需模組, 然後執行下列 zmqRemoteAPI IPv6 程式, 將滑鼠在場景中點擊後, 按下 q 鍵即可終止場景模擬: \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n 8 \n 9 \n 10 \n 11 \n 12 \n 13 \n 14 \n 15 \n 16 \n 17 \n 18 \n 19 \n 20 \n 21 \n 22 \n 23 \n 24 \n 25 \n 26 \n 27 \n 28 \n 29 \n 30 \n 31 \n 32 \n 33 \n 34 \n 35 \n 36 \n 37 \n 38 \n 39 \n 40 \n 41 \n 42 \n 43 \n 44 \n 45 \n 46 \n 47 \n 48 \n 49 \n 50 \n 51 \n 52 \n 53 \n 54 \n 55 \n 56 \n 57 \n 58 \n 59 \n 60 \n 61 \n 62 \n 63 \n 64 \n 65 \n 66 \n 67 \n 68 \n 69 \n 70 \n 71 \n \n \n \n # zmqRemoteApi_IPv6 為將 zmq 通訊協定修改為 IPv4 與 IPv6 相容 \n # pip install pyzmq cbor keyboard \n from   zmqRemoteApi_IPv6  import   RemoteAPIClient \n import   time \n import   math \n import   keyboard \n \xa0 \n # 利用 zmqRemoteAPI 以 23000 對場景伺服器進行連線 \n client  =   RemoteAPIClient( \'localhost\' ,  23000 ) \n # 以 getObject 方法取得場景物件 \n sim  =   client.getObject( \'sim\' ) \n box  =   sim.getObject( \'/box\' ) \n \xa0 \n # 啟動模擬 \n sim.startSimulation() \n # 建立尺寸數列, 分別定義 x, y, z 方向尺寸 \n x  =   0.2 \n y  =   0.2 \n z  =   0.1 \n size  =   [x, y, z] \n \xa0 \n # 利用 size 數列, 建立圓柱物件, 2 代表 cylinder \n # 8 表示 respondable, 1 為 質量 \n digit1_handle  =   sim.createPureShape( 2 ,  8 , size,  1 ,  None ) \n # 將圓柱物件命名為 digit1, 若用於機械計分可做為個位數轉盤 \n # 之後可再導入帶有數字組立的外型零件 \n sim.setObjectAlias(digit1_handle,  \'digit1\' ) \n # 轉角單位為徑度 \n sim.setObjectOrientation(digit1_handle,  - 1 , [ 0 , math.pi / 2 ,  0 ]) \n # 起始物件中心位於 [0, 0, 0], 為了位於地板, 往 z 提升一個半徑高度 \n sim.setObjectPosition(digit1_handle,  - 1 , [ 0 ,  0 , x / 2 ]) \n \xa0 \n # 建立 revolute joint 命名為 joint, 且將 joint mode 設為 dynamic, control mode 設為 velocity \n joint1_handle  =   sim.createJoint(sim.joint_revolute_subtype, sim.jointmode_dynamic,  0 ,  None ) \n sim.setObjectInt32Param(joint1_handle, sim.jointintparam_dynctrlmode, sim.jointdynctrl_velocity) \n sim.setObjectAlias(joint1_handle,  \'joint1\' ) \n \xa0 \n # 取得 cylinder 的位置座標 \n digit1_pos  =   sim.getObjectPosition(digit1_handle,  - 1 ) \n joint1_pos  =   [digit1_pos[ 0 ], digit1_pos[ 1 ], digit1_pos[ 2 ]] \n \xa0 \n # 將 joint1 至於 cylinder 中心 \n sim.setObjectPosition(joint1_handle,  - 1 , joint1_pos) \n # 取得 digit1_handle 的方位 \n digit1_ori  =   sim.getObjectOrientation(digit1_handle,  - 1 ) \n # 將 joint1_handle 方位與 digit1 對齊 \n sim.setObjectOrientation(joint1_handle,  - 1 , digit1_ori) \n \xa0 \n # 將 joint1 置於 box 上 \n sim.setObjectParent(joint1_handle, box,  True ) \n # 將 cylinder 置於 joint1 上 \n sim.setObjectParent(digit1_handle, joint1_handle,  True ) \n \xa0 \n # 鎖定 joint1 \n sim.setJointForce(joint1_handle,  float ( \'inf\' )) \n \xa0 \n print ( "基本場景建立完成!" ) \n \xa0 \n # 設定主迴圈 \n while   True : \n \xa0\xa0\xa0\xa0 # 設定 joint1 目標速度 \n \xa0\xa0\xa0\xa0 sim.setJointTargetVelocity(joint1_handle,  10 ) \n \xa0\xa0\xa0\xa0 # 讓 coppeliasim 有時間按照設定讓 joint1 旋轉 \n \xa0\xa0\xa0\xa0 time.sleep( 0.01 )  \n \xa0 \n \xa0\xa0\xa0\xa0 if   keyboard.is_pressed( \'q\' ): \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 # 可以按下 q 鍵跳出重複執行迴圈 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 break \n \xa0 \n # 終止模擬 \n sim.stopSimulation() \n \n \n \n \n \n \n \n 下載 \xa0 zmqRemoteAPI Python for cad2023.7z \xa0 (需要下載密碼) \n 在 \xa0 simpleMagnetDemo.ttt \xa0 中利用 Lua 以 proximity sensor 感測與物體的距離後, 產生電磁吸引力的範例程式: \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n 8 \n 9 \n 10 \n 11 \n 12 \n 13 \n 14 \n 15 \n 16 \n 17 \n 18 \n 19 \n 20 \n 21 \n 22 \n 23 \n 24 \n 25 \n 26 \n 27 \n 28 \n 29 \n 30 \n 31 \n 32 \n 33 \n 34 \n 35 \n 36 \n 37 \n 38 \n 39 \n 40 \n 41 \n 42 \n 43 \n 44 \n 45 \n 46 \n 47 \n 48 \n 49 \n 50 \n 51 \n 52 \n 53 \n 54 \n \n \n \n function   sysCall_init() \n \xa0\xa0\xa0\xa0\xa0 -- 初始化 callback 函數，在模擬開始時執行 \n \xa0\xa0\xa0\xa0\xa0 sensor = sim.getObject( \'./sensor\' ) \n \xa0\xa0\xa0\xa0\xa0 -- 取得命名為 \'sensor\' 的物件 handle。 此處使用 proximity 感測器，用於檢測物體之間的距離 \n \xa0\xa0\xa0\xa0\xa0 shape = sim.getObject( \'.\' ) \n \xa0\xa0\xa0\xa0\xa0 -- 取得目前 script 所依附的物件 handle，即包含此 script 的物件 handle \n \xa0\xa0\xa0\xa0\xa0 sim.setObjectInt32Param(shape, sim.shapeintparam_static, 0) \n \xa0\xa0\xa0\xa0\xa0 -- 將物體設定為非靜態，讓其在模擬中發生動態運動 \n \xa0\xa0\xa0\xa0\xa0 nominalForce = 0.001 \n \xa0\xa0\xa0\xa0\xa0 -- 設定電磁吸引力的標準值 \n \xa0\xa0\xa0\xa0\xa0 enabled =  true \n \xa0\xa0\xa0\xa0\xa0 -- 啟用電磁吸引力 \n \xa0\xa0\xa0\xa0\xa0 previousPos = sim.getObjectPosition(shape, sim.handle_world) \n \xa0\xa0\xa0\xa0\xa0 -- 取得物體的初始位置並儲存在 previousPos 變數中，用於偵測物體是否移動 \n end \n \xa0 \n function   sysCall_actuation() \n \xa0\xa0\xa0\xa0\xa0 -- 驅動 callback 函數，在每個模擬步驟中執行 \n \xa0\xa0\xa0\xa0\xa0 if   enabled  then \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 -- 如果啟用電磁吸引力，執行下列程式碼 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 local   r, dist, pt, obj = sim.handleProximitySensor(sensor) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 -- 使用 proximity 感測器偵測物體是否接近 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 if   r > 0  then \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 -- 如果偵測到物體 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 dist = dist + 0.02 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 -- 增加一個 offset，以避免物體接觸時產生無限大的吸引力 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 local   force = nominalForce / (dist * dist) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 -- 計算吸引力的大小，與距離的平方成反比 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 local   m = sim.getObjectMatrix(shape, sim.handle_world) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 m[4] = 0 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 m[8] = 0 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 m[12] = 0 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 -- 取得物體的轉換矩陣，不考慮平移部分 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 local   forceVector = sim.multiplyVector(m, {0, 0, force}) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 -- 將力向量從局部座標系轉換為絕對座標系 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 sim.addForceAndTorque(shape, forceVector, {0, 0, 0}) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 -- 將計算得到的力應用於物體的質心，持續一個 time step \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 if   notFirstPass  then \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 local   p = sim.getObjectPosition(shape, sim.handle_world) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 local   dx = {p[1] - previousPos[1], p[2] - previousPos[2], p[3] - previousPos[3]} \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 local   d =  math.sqrt (dx[1] * dx[1] + dx[2] * dx[2] + dx[3] * dx[3]) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 -- 計算物體是否移動 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 if   d < 0.0001  then \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 sim.setObjectInt32Param(shape, sim.shapeintparam_static, 1) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 sim.resetDynamicObject(shape) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 enabled =  false \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 -- 如果物體沒有移動，將其設為靜態 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 end \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 previousPos = p \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 end \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 end \n \xa0\xa0\xa0\xa0\xa0 end \n \xa0\xa0\xa0\xa0\xa0 notFirstPass =  true \n end \n \n \n \n \n \n \n \n', 'tags': '', 'url': '磁力吸引.html'}, {'title': 'magnet', 'text': '利用 Lua 模擬磁力的程式碼: \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n 8 \n 9 \n 10 \n 11 \n 12 \n 13 \n 14 \n 15 \n 16 \n 17 \n 18 \n 19 \n 20 \n 21 \n 22 \n 23 \n 24 \n 25 \n 26 \n 27 \n 28 \n 29 \n 30 \n 31 \n 32 \n 33 \n 34 \n 35 \n 36 \n 37 \n 38 \n 39 \n 40 \n 41 \n 42 \n 43 \n 44 \n 45 \n 46 \n 47 \n 48 \n 49 \n 50 \n 51 \n 52 \n 53 \n 54 \n 55 \n 56 \n 57 \n 58 \n 59 \n 60 \n 61 \n 62 \n 63 \n 64 \n 65 \n 66 \n 67 \n 68 \n 69 \n 70 \n 71 \n 72 \n 73 \n 74 \n 75 \n 76 \n 77 \n 78 \n 79 \n 80 \n 81 \n 82 \n 83 \n 84 \n 85 \n 86 \n 87 \n 88 \n 89 \n 90 \n 91 \n 92 \n 93 \n 94 \n 95 \n 96 \n 97 \n 98 \n 99 \n 100 \n 101 \n 102 \n 103 \n 104 \n 105 \n 106 \n 107 \n 108 \n 109 \n 110 \n 111 \n 112 \n 113 \n 114 \n 115 \n 116 \n 117 \n 118 \n 119 \n 120 \n 121 \n 122 \n 123 \n 124 \n 125 \n 126 \n \n \n \n function   sysCall_init() \n \xa0 \n -- This line defines the beginning of a function called sysCall_init(). This function is a special callback function in CoppeliaSim that gets called once when the simulation starts. \n \xa0 \n \xa0\xa0\xa0\xa0 sensor = sim.getObject( \'./sensor\' ) \n \xa0 \n -- In this line, the script is getting a reference to an object named "sensor" in the simulation scene. This object is expected to exist within the same hierarchy as the script. \n \xa0 \n \xa0\xa0\xa0\xa0 shape = sim.getObject( \'.\' ) \n \xa0 \n -- Here, the script is getting a reference to the object where the script is attached. The dot . represents the current object. \n \xa0 \n \xa0\xa0\xa0\xa0 sim.setObjectInt32Param(shape, sim.shapeintparam_static, 0) \n \xa0 \n -- This line is setting an integer parameter for the "shape" object. Specifically, it\'s setting the sim.shapeintparam_static parameter to 0. This means that the "shape" object is initially not considered as a static object. \n \xa0 \n \xa0\xa0\xa0\xa0 nominalForce = 0.001 \n \xa0 \n -- This line sets a variable nominalForce to a value of 0.001. It appears to represent a constant force value used in the script. \n \xa0 \n \xa0\xa0\xa0\xa0 enabled =  true \n \xa0 \n -- This line initializes a boolean variable enabled to true. This variable seems to control whether the script should apply forces or not. \n \xa0 \n \xa0\xa0\xa0\xa0 previousPos = sim.getObjectPosition(shape, sim.handle_world) \n \xa0 \n -- Here, the script is getting the initial position of the "shape" object in the world coordinate system and storing it in the previousPos variable. This will be used later for checking if the object has moved. \n \xa0 \n -- The sysCall_init function sets up initial parameters and conditions for the script. It\'s executed once at the beginning of the simulation. \n \xa0 \n -- Now, let\'s move on to the sysCall_actuation function: \n \xa0 \n function   sysCall_actuation() \n \xa0 \n -- This line defines the beginning of another special callback function in CoppeliaSim called sysCall_actuation(). This function gets called repeatedly during the simulation to perform actions in each time step. \n \xa0 \n \xa0\xa0\xa0\xa0 if   enabled  then \n \xa0 \n -- This line checks if the enabled variable is true. If it\'s true, it means the script should apply forces. If it\'s false, the script won\'t apply any forces. \n \xa0 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 local   r, dist, pt, obj = sim.handleProximitySensor(sensor) \n \xa0 \n -- Here, the script is using the sim.handleProximitySensor function to check if the proximity sensor (defined earlier as "sensor") is detecting any objects nearby. It returns information about the detected object. \n \xa0 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 if   r > 0  then \n \xa0 \n -- This line checks if r (the return value of the proximity sensor function) is greater than 0. If it is, it means the sensor has detected an object nearby. \n \xa0 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 dist = dist + 0.02 \n \xa0 \n -- This line adds an offset of 0.02 to the dist variable. This offset is added to prevent an infinite force when objects are in direct contact. It\'s a safety measure. \n \xa0 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 local   force = nominalForce / (dist * dist) \n \xa0 \n -- Here, the script calculates the force to be applied based on the nominalForce and the squared distance (dist) between the object and the detected object. This seems to be a simple inverse square law force calculation. \n \xa0 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 local   m = sim.getObjectMatrix(shape, sim.handle_world) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 m[4] = 0 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 m[8] = 0 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 m[12] = 0 \n \xa0 \n -- These lines retrieve the transformation matrix (m) of the "shape" object with respect to the world coordinate system and set its translational components to 0. This effectively extracts the rotational part of the transformation matrix. \n \xa0 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 local   forceVector = sim.multiplyVector(m, {0, 0, force}) \n \xa0 \n -- This line multiplies the modified transformation matrix m by a force vector {0, 0, force} to obtain a force vector in absolute world coordinates. \n \xa0 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 sim.addForceAndTorque(shape, forceVector, {0, 0, 0}) \n \xa0 \n -- Here, the script applies the computed forceVector to the "shape" object using sim.addForceAndTorque. This function applies the force to the center of mass of the object for one simulation time step. \n \xa0 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 if   notFirstPass  then \n \xa0 \n -- This line checks if the notFirstPass variable is true. It\'s used to ensure that this part of the script is executed after the first simulation step. \n \xa0 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 local   p = sim.getObjectPosition(shape, sim.handle_world) \n \xa0 \n -- Here, the script is getting the current position of the "shape" object in the world coordinate system. \n \xa0 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 local   dx = {p[1] - previousPos[1], p[2] - previousPos[2], p[3] - previousPos[3]} \n \xa0 \n -- This line calculates the difference in position (dx) between the current position (p) and the previous position (previousPos) of the object in world coordinates. \n \xa0 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 local   d =  math.sqrt (dx[1] * dx[1] + dx[2] * dx[2] + dx[3] * dx[3]) \n \xa0 \n -- The script calculates the Euclidean distance d based on the differences in position components dx. This distance is used to check if the object has moved significantly. \n \xa0 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 if   d < 0.0001  then \n \xa0 \n -- This line checks if the object has moved by comparing d to a small threshold value (0.0001). If d is less than the threshold, it means the object hasn\'t moved significantly. \n \xa0 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 sim.setObjectInt32Param(shape, sim.shapeintparam_static, 1) \n \xa0 \n -- If the object hasn\'t moved significantly, this line sets the sim.shapeintparam_static parameter to 1, making the object static in the simulation. \n \xa0 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 sim.resetDynamicObject(shape) \n \xa0 \n -- This line resets the dynamics of the object. It might be necessary to reset the object\'s dynamics after making it static to avoid any issues. \n \xa0 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 enabled =  false \n \xa0 \n -- Finally, this line sets the enabled variable to false, which will prevent the script from applying further forces since the object is now considered static and not moving. \n \xa0 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 end \n \xa0 \n -- The if block is closed. \n \xa0 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 previousPos = p \n \xa0 \n -- Regardless of whether the object has become static or not, the previousPos variable is updated with the current position for use in the next iteration of the sysCall_actuation function. \n \xa0 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 end \n \xa0 \n -- The if notFirstPass block is closed. \n \xa0 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 end \n \xa0 \n -- The if r > 0 block is closed. \n \xa0 \n \xa0\xa0\xa0\xa0 end \n \xa0 \n -- The if enabled block is closed. \n \xa0 \n \xa0\xa0\xa0\xa0 notFirstPass =  true \n \xa0 \n -- This line sets the notFirstPass variable to `true \n \n \n \n \n \n \n \n', 'tags': '', 'url': 'magnet.html'}, {'title': '馬達推動', 'text': '除了利用磁力吸引, 讓鋼球在軌道運動時能具備足夠動能返回圓形平台外, 另外一種設計是在鋼球 (或其他非鐵材質的圓球) 離開圓形平台孔洞之後, 設法利用隱藏式的馬達帶動機構, 以滾動方式加速圓球, 以便讓圓球返回平台. \n 有關馬達推動設計, 請參考: \xa0 https://www.instructables.com/Marblevator-Perpetual/ \xa0 或 這個影片 . \n 機電模擬系統: \n 下載 \xa0 CoppeliaSimEdu_4.5.1_rev4_for_cd2023.7z \xa0 (需要下載密碼) \n CoppeliaSim 使用者手冊 , \xa0 CoppeliaSim 4.3.0 使用手冊網站 \n', 'tags': '', 'url': '馬達推動.html'}, {'title': '網路設定', 'text': '\n 由於電腦輔助設計室某部分套件, 在 IPv4 網路環境下會被防毒軟體偵測到封包異常而封閉網路, 因此以下將 IPv4 網路關閉, 僅使用 IPv6, 並透過雙網路協定支援的代理主機設定, 以便與僅支援 IPv4 的網路主機連線. \n 利用隨身碟上的批次檔案進行電腦輔助設計室網路環境設定 ( 設定影片 ): \n 1_cadlab_network_setup.bat \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n \n \n \n echo  "disable ipv4 and setup proxy for ipv6" \n SET CurrentDir=%~dp0 \n %windir%\\system32\\reg.exe import %CurrentDir%1_2023_cadlab_network_setup.reg \n powershell -executionpolicy bypass -File %CurrentDir%1_disable_ipv4.ps1 \n exit \n \n \n \n \n \n \n \n 1_2023_cadlab_network_setup.reg \n 關閉自動搜尋代理主機, 自行設定代理主機外, 對近端與 NAT 內部 IPv4 網址不使用 proxy server, 若 proxy server 採 domain name 設定則當 IPv4 網路協定啟動時, 亦可透過代理主機連線. \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n 8 \n 9 \n 10 \n 11 \n \n \n \n Windows Registry Editor Version 5.00 \n \xa0 \n \xa0 [HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings] \n \xa0 ; disable AutoDetect \n "AutoDetect" =dword:00000000 \n "MigrateProxy" =dword:00000001 \n ; enable Proxy \n "ProxyEnable" =dword:00000001  \n "ProxyHttp1.1" =dword:00000000  \n "ProxyServer" = "http://p4.cycu.org:3128" \n "ProxyOverride" = "localhost;192.168.1.0/24;<local>" \n \n \n \n \n \n \n \n 1_disable_ipv4.ps1 \n 僅啟動 IPv6 網路協定, 且將 dns server 指向 hinet. \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n 8 \n 9 \n 10 \n 11 \n 12 \n 13 \n 14 \n 15 \n 16 \n 17 \n 18 \n 19 \n 20 \n 21 \n 22 \n 23 \n 24 \n 25 \n 26 \n 27 \n 28 \n \n \n \n # 關閉 IPv4 網路 \n Disable-NetAdapterBinding -Name  "*"   -ComponentID ms_tcpip \n \xa0\xa0 \xa0 \n # 啟用 IPv6 網路 \n Enable-NetAdapterBinding -Name  "*"   -ComponentID ms_tcpip6 \n \xa0\xa0 \xa0 \n # 設置 IPv6 網路中的兩個 DNS 伺服器 (hinet) \n $dnsServers =  "2001:b000:168::1" ,  "2001:b000:168::2" \n Set-DnsClientServerAddress -InterfaceAlias  "*"   -ServerAddresses $dnsServers \n \xa0 \n \xa0 \n # 設定 IPv6 固定位址 (fixed address), 子網路首碼長度 (subnet prefix) 與網路預設閘道 (gateway) 等三個變數 \n $ipv6Address =  "2001:288:6004:17:請使用個人所分配到的 IPv6 位址" \n $subnetPrefixLength = 64 \n $gateway =  "2001:288:6004:17::254" \n \xa0 \xa0 \n # 參考 https://serverfault.com/questions/427234/getting-network-interface-device-name-in-powershell \n $query =  "SELECT * FROM Win32_NetworkAdapter WHERE Manufacturer != \'Microsoft\' AND NOT PNPDeviceID LIKE \'ROOT\\\\%\'" \n $interfaces = Get-WmiObject -Query $query | Sort index \n $interfaces | ForEach{ \n \xa0\xa0\xa0\xa0 $friendlyname = $_ | ForEach-Object { $_.NetConnectionID } \n \xa0\xa0\xa0\xa0 New-NetIPAddress -AddressFamily  "IPv6"   -InterfaceAlias $friendlyname -IPAddress $ipv6Address -PrefixLength $subnetPrefixLength -DefaultGateway $gateway \n } \n \xa0 \n \xa0 \xa0 \n # 列出所使用的 IPv6 網路通訊協定內容 \n Write-Host  "IPv6 Address: $ipv6Address/$subnetPrefixLength" \n Write-Host  "IPv6 Gateway: $gateway" \n \n \n \n \n \n \n \n 下載 \xa0 cad2023_network_setup.7z \xa0 (需要下載密碼), 必須以管理者身分執行批次檔案, 因為要藉此身分關閉 IPv4 網路協定. \n 下載 \xa0 2023_fall_w7_cadlab_network_setup.7z \xa0 (需要下載密碼), 必須先放入個人所分配到的 IPv6 位址後, 以管理者身分執行批次檔案, 就能直接完成電腦輔助設計室中電腦的網路連線設定. \n 各學員所分配的固定 IPv6 位址如下: \n 2a 學員展示用 IPv6 位址: 2001:288:6004:17:2023:cada:: 班級名單序號 \n 2b 學員展示用 IPv6 位址: 2001:288:6004:17:2023:cadb:: 班級名單序號 \n w15 << \xa0 Previous \xa0 Next \xa0 >> exam \n \n \n Copyright ©2024 All rights reserved | This template is made with \xa0 \xa0 by \xa0 Colorlib \n', 'tags': '', 'url': '網路設定.html'}, {'title': '課程總結', 'text': '標題：電腦輔助設計與實習心得 \n 日期：[1/11] \n', 'tags': '', 'url': '課程總結.html'}, {'title': '簡介', 'text': '在這段時間內，我有幸參與了一場電腦輔助設計的實習，透過這次經驗，我深刻體會到了電腦輔助設計的重要性以及對於實際工作的裨益。以下是我在實習過程中的心得分享。 \n', 'tags': '', 'url': '簡介.html'}, {'title': '背景', 'text': '我進行的實習是在一家工程設計公司，主要負責電腦輔助設計領域的相關任務。這包括使用各種設計軟體來協助產品設計和模擬，提高設計效率和確保產品的品質。 \n', 'tags': '', 'url': '背景.html'}, {'title': '學習與成長', 'text': '', 'tags': '', 'url': '學習與成長.html'}, {'title': '1. 軟體技能提升', 'text': '透過這次實習，我得以深入學習並熟練使用了許多先進的電腦輔助設計軟體，例如SolidWorks、AutoCAD等。這些工具不僅提高了我的設計能力，還讓我能夠更加靈活地應對各種複雜的設計挑戰。 \n', 'tags': '', 'url': '1. 軟體技能提升.html'}, {'title': '2. 團隊合作', 'text': '在公司中，我參與了多個團隊項目，這促使我與其他設計師、工程師和專業人員進行有效的溝通和合作。這不僅擴展了我的人際交往能力，也提升了我在團隊中發揮協同作用的能力。 \n', 'tags': '', 'url': '2. 團隊合作.html'}, {'title': '3. 解決問題的能力', 'text': '在實際的設計工作中，我遇到了許多挑戰和問題，這促使我不斷學習和改進。透過與同事的討論和尋求專業指導，我學會了如何快速而有效地解決各種技術和設計上的問題。 \n', 'tags': '', 'url': '3. 解決問題的能力.html'}, {'title': '意義與啟示', 'text': '', 'tags': '', 'url': '意義與啟示.html'}, {'title': '1. 技能轉換', 'text': '這次實習不僅加強了我在電腦輔助設計方面的技能，還啟發我思考如何將這些技能應用於其他領域。我相信這樣的技能轉換將對我的未來職業生涯產生深遠的影響。 \n', 'tags': '', 'url': '1. 技能轉換.html'}, {'title': '2. 專業發展', 'text': '這次實習為我提供了一個寶貴的機會，讓我更深入地了解了我所選擇的專業領域。這將有助於我制定更清晰的職業發展計劃，確保我在未來的職業生涯中更有針對性地發展自己的技能和專業知識。 \n', 'tags': '', 'url': '2. 專業發展.html'}, {'title': '結語', 'text': '這段時間的電腦輔助設計實習經歷，不僅讓我學到了豐富的知識，還讓我更加深刻地體會到設計在現代科技發展中的不可或缺性。我將這次的實習視為我職業生涯中的一個重要里程碑，並期待能夠將所學應用於未來的挑戰之中。 \n', 'tags': '', 'url': '結語.html'}]};